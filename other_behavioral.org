#+TITLE: Other Behavioral Patterns

In this chapter we will look at 5 behavioral patterns:

- Interpreter
  - Give the ability to use an embedded little language inside of an application
- Strategy
  - Given multiple algorithms for a problem, decide which algorithm to use
- Memento
  - Add support for Undo and/or History in an application
- Iterator
  - Handle a container of objects and traverse the members one at a time with next semantics
- Template
  - Eliminate code redundancy by redefining certain parts of an algorithm without changing its structure

* Interpreter Pattern

The goal is to offer the right programming abstractions to the specialist, who is often not a programmer, to make them productive.

* Implementation

We will create an internal DSL to control a smart house.
The user is able to control things using a very simple event notation. An event has the form of
command -> receiver -> arguments
Not all events require arguments. Example:
open -> gate
increase -> boiler temperature -> 3 degrees


Before we code, we can define the grammar using Backus-Naur Form notation:

#+BEGIN_SRC backus-naur-form
event ::= command token receiver token arguments
word ::= a collection of one or more alphanumeric characters
token ::= ->
command ::= word+
receiver ::= word+
arguments ::= word+
#+END_SRC


#+BEGIN_SRC python :tangle boiler_interpreter.py
import pyparsing as pyp

# implement BNF
word = pyp.Word(pyp.alphanums)
token = pyp.Suppress("->")

command = pyp.Group(pyp.OneOrMore(word))
device = pyp.Group(pyp.OneOrMore(word))
argument = pyp.Group(pyp.OneOrMore(word))

event = command + token + device + pyp.Optional(token + argument)

class Boiler:
    def __init__(self):
        self.temperature = 83

    def __str__(self):
        return f"Boiler temperature: {self.temperature}"

    def increase_temperature(self, amount):
        print(f"Increasing the boiler's temperature by {amount} degrees (C)")
        self.temperature += amount

    def decrease_temperature(self, amount):
        print(f"Decreasing the boiler's temperature by {amount} degrees (C)")
        self.temperature -= amount


class Gate:
    def __init__(self):
        self.is_open = False

    def __str__(self):
        return "open" if self.is_open else "closed"

    def open(self):
        print("opening the gate")
        self.is_open = True

    def close(self):
        print("closing the gate")
        self.is_open = False


class Garage:
    def __init__(self):
        self.is_open = False

    def __str__(self):
        return "open" if self.is_open else "closed"

    def open(self):
        print("opening the garage")
        self.is_open = True

    def close(self):
        print("closing the garage")
        self.is_open = False


class AirCondition:
    def __init__(self):
        self.is_on = False

    def __str__(self):
        return "on" if self.is_on else "off"

    def turn_on(self):
        print("turning on the A/C")
        self.is_on = True

    def turn_off(self):
        print("turning off the A/C")
        self.is_on = False


class Heating:
    def __init__(self):
        self.is_on = False

    def __str__(self):
        return "on" if self.is_on else "off"

    def turn_on(self):
        print("turning on the Heat")
        self.is_on = True

    def turn_off(self):
        print("turning off the Heat")
        self.is_on = False


class Fridge:
    def __init__(self):
        self.temperature = 2

    def __str__(self):
        return f"fridge temperature: {self.temperature}"

    def increase_temperature(self, amount):
        print(f"increasing the fridge's temperature by {amount} degrees")
        self.temperature += amount

    def decrease_temperature(self, amount):
        print(f"decreasing the fridge's temperature by {amount} degrees")
        self.temperature -= amount

gate = Gate()
garage = Garage()
airco = AirCondition()
heating = Heating()
boiler = Boiler()
fridge = Fridge()


def main():
    tests = (
        "open -> gate",
        "close -> garage",
        "turn on -> air condition",
        "turn off -> heating",
        "increase -> boiler temperature -> 5 degrees",
        "decrease -> fridge temperature -> 2 degrees"
    )

    open_actions = {"gate": gate.open,
                    "garage": garage.open,
                    "air condition": airco.turn_on,
                    "heating": heating.turn_on,
                    "boiler temperature": boiler.increase_temperature,
                    "fridge temperature": fridge.increase_temperature}

    close_actions = {"gate": gate.close,
                    "garage": garage.close,
                    "air condition": airco.turn_off,
                    "heating": heating.turn_off,
                    "boiler temperature": boiler.decrease_temperature,
                    "fridge temperature": fridge.decrease_temperature}

    for t in tests:
        if len(event.parseString(t)) == 2:  # no argument
            cmd, dev = event.parseString(t)
            cmd_str, dev_str = " ".join(cmd), " ".join(dev)
            if "open" in cmd_str or "turn on" in cmd_str:
                open_actions[dev_str]()
            elif "close" in cmd_str or "turn off" in cmd_str:
                close_actions[dev_str]()
        elif len(event.parseString(t)) == 3:  # argument
            cmd, dev, arg = event.parseString(t)
            cmd_str, dev_str, arg_str = " ".join(cmd), " ".join(dev), " ".join(arg)
            num_arg = 0
            try:
                num_arg = int(arg_str.split()[0])  # extract the numeric part
            except ValueError as err:
                print(f"Expected number but got: {arg_str[0]}")
            if "increase" in cmd_str and num_arg > 0:
                open_actions[dev_str](num_arg)
            elif "decrease" in cmd_str and num_arg > 0:
                close_actions[dev_str](num_arg)

if __name__ == '__main__':
    main()
#+END_SRC
