#+TITLE: The Builder Pattern

Imagine we want to create an object that is composed of multiple parts and the composition needs to be done step by step.
The builder pattern separates the construction of a complex object from its representation. This way the construction can
be used to create several different representations.

Suppose we want to create an HTML page generator.
We can create one with the builder pattern consisting of two main participants:
- The Builder: The component responsible for creating the various parts of a complex object. In this example, the title, heading, body, and footer of the page
- The Director: Controls the building process using a *builder* instance. It calls the builder's functions for setting the title, heading, and so on. Using a different builder allows us to create a different HTML page without touching any of the code of the director.

* Use Cases

#+BEGIN_SRC python
# Factory pattern with prebuilt computer. Buying an Apple Mac Mini
MINI14 = '1.4GHz Mac Mini'

class AppleFactory:
    # nested classes to forbid direct instantiation of the class
    class MacMini14:
        def __init__(self):
            self.memory = 4
            self.hdd = 500
            self.gpu = 'Intel HD Graphics 5000'

        def __str__(self):
            info = (f'Model: {MINI14}',
                    f'Memory: {self.memory} GB',
                    f'Hard Disk: {self.hdd} GB',
                    f'Graphics Card: {self.gpu}')
            return '\n'.join(info)

    def build_computer(self, model):
        if model == MINI14:
            return self.MacMini14()
        else:
            print(f"I don't know how to build {model}")

if __name__ == '__main__':
    afac = AppleFactory()
    mac_mini = afac.build_computer(MINI14)
    print(mac_mini)
#+END_SRC

#+BEGIN_SRC python :tangle computer_builder.py
# Builder Pattern. Building a custom PC
class Computer:
    def __init__(self, serial_number):
        self.serial = serial_number
        self.memory = None
        self.hdd = None
        self.gpu = None

    def __str__(self):
        info = (f'Memory: {self.memory} GB',
                f'Hard Disk: {self.hdd} GB',
                f'Graphics Card: {self.gpu}')
        return '\n'.join(info)


class ComputerBuilder:
    def __init__(self):
        self.computer = Computer('AG23385193')

    def configure_memory(self, amount):
        self.computer.memory = amount

    def configure_hdd(self, amount):
        self.computer.hdd = amount

    def configure_gpu(self, gpu_model):
        self.computer.gpu = gpu_model


class HardwareEngineer:
    def __init__(self):
        self.builder = None

    def construct_computer(self, memory, hdd, gpu):
        self.builder = ComputerBuilder()
        steps = (self.builder.configure_memory(memory),
                 self.builder.configure_hdd(hdd),
                 self.builder.configure_gpu(gpu))
        [step for step in steps]

    @property
    def computer(self):
        return self.builder.computer


def main():
    engineer = HardwareEngineer()
    engineer.construct_computer(hdd=500,
                                memory=8,
                                gpu='GeForce GTX 650 Ti')
    computer = engineer.computer
    print(computer)


if __name__ == '__main__':
    main()
#+END_SRC

* Implementation

We will be building a pizza-ordering application.

#+BEGIN_SRC python
from enum import Enum
import time
#+END_SRC
